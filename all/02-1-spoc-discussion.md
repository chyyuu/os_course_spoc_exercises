#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。

  新型UEFI，全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)， 是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。与BIOS显著不同的是，UEFI是用模块化、C语言风格的参数堆栈传递方式、动态链接的形式构建系统，它比BIOS更易于实现，容错和纠错特性也更强，从而缩短了系统研发的时间。更加重要的是，它运行于32位或64位模式，突破了传统16位代码的寻址能力，达到处理器的最大寻址，此举克服了BIOS代码运行缓慢的弊端。

 1. 描述PXE的大致启动流程。

  PXE无盘工作站的启动过程分析如下：
  1. 客户端个人电脑开机后， 在 TCP/IP Bootrom 获得控制权之前先做自我测试。
  2. Bootprom 送出 BOOTP/DHCP 要求以取得 IP。
  3. 如果服务器收到个人电脑所送出的要求， 就会送回 BOOTP/DHCP 回应，内容包括
  客户端的 IP 地址， 预设网关， 及开机映像文件。否则，服务器会忽略这个要求。
  4. Bootprom 由 TFTP 通讯协议从服务器下载开机映像文件。
  5. 个人电脑通过这个开机映像文件开机， 这个开机文件可以只是单纯的开机程式也可
  以是操作系统。
  6. 开机映像文件将包含 kernel loader 及压缩过的 kernel，此 kernel 将支持NTFS root
  系统。
  7. 远程客户端根据下载的文件启动机器。


## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
    
    Windows XP在引导过程中将经历预引导、引导和加载内核三个阶段。NTLDR在这三个阶段的引导过程中将起到至关重要的作用。
 1. 了解GRUB的启动流程。
    
    GRUB的执行流程：当系统加电后，固化在BIOS中的程序首先对系统硬件进行自检，自检通过后，就加载启动磁盘上的MBR，并将控制权交给MBR中的程序(stage1)，stage1执行，判断自己是否GRUB，如果是且配置了stage1_5，则加载stage1_5，否则就转去加载启动扇区，接着，stage2被加载并执行，由stage2借助stage1_5驱动文件系统，并查找grub.conf，显示启动菜单供用户选择，然后根据用户的选择或默认配置加载操作系统内核，并将控制权交给操作系统内核，由内核完成操作系统的启动。
 1. 比较NTLDR和GRUB的功能有差异。
    
    ntldr功能很少，只能引导win，只能装在硬盘；
    grub是第三方操作系统引导器，可以引导硬盘，光盘，网络，U盘，
 1. 了解u-boot的功能。
    
    U-Boot可支持的主要功能列表：
    * 系统引导支持NFS挂载、RAMDISK(压缩或非压缩)形式的根文件系统；支持NFS挂载、从FLASH中引导压缩或非压缩系统内核；
    * 基本辅助功能强大的操作系统接口功能；可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤以Linux支持最为强劲；支持目标板环境参数多种存储方式，如FLASH、NVRAM、EEPROM；
    * CRC32校验可校验FLASH中内核、RAMDISK镜像文件是否完好；
    * 设备驱动串口、SDRAM、FLASH、以太网、LCD、NVRAM、EEPROM、键盘、USB、PCMCIA、PCI、RTC等驱动支持；
    * 上电自检功能SDRAM、FLASH大小自动检测；SDRAM故障检测；CPU型号；
    * 特殊功能XIP内核引导；`

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
    
    中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

    Linux系统有上百个系统调用，主要功能分类：进程控制、文件系统控制、系统控制
 ```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
  
  ucore的系统调用大致有二十几个，主要分类为文件操作，进程管理，内存管理等
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
    
    * objdump命令：Linux下的反汇编目标文件或者可执行文件的命令
    * nm命令：显示关于对象文件、可执行文件以及对象文件库里的符号信息
    * file命令：检测文件类型
    * Linux系统调用编写：
        1. 指明系统调用的类型：
            movl  $SYS_write,%eax
        2. 将系统调用的参数压栈：
            movl  $STDOUT,%ebx
            movl  $hello,%ecx
            movl  $12,%edx
        5. 通过int指令将用户态的执行模式转变为内核态，并将将控制权交回给系统调用的起点system_call()处理函数：
            int $0x80   

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 
    * strace常用来跟踪进程执行时的系统调用和所接收的信号，可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间
    * Linux应用的系统调用执行过程：
      1. 流程：用户程序 --> C库(即API)：INT 0x80 --> system_call --> 系统调用服务例程 --> 内核程序
      2. 应用程序将系统调用参数压栈然后通过执行软终端指令INT 0x80会让系统跳转到一个预设的内核空间地址，它指向系统调用处理程序，即system_call函数。system_call再根据具体的系统调用号转到执行具体的系统调用服务例程。完成后，控制又返回到发出系统调用命令之后的一条指令，被中断的程序将继续执行下去。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
 系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件(存储器)的操作，都必然会引起系统调用。也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
