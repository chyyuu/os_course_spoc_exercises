#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 1. 描述PXE的大致启动流程。

1.UEFI，全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)， 是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。与BIOS显著不同的是，UEFI是用模块化、C语言风格的参数堆栈传递方式、动态链接的形式构建系统，它比BIOS更易于实现，容错和纠错特性也更强，从而缩短了系统研发的时间。更加重要的是，它运行于32位或64位模式，突破了传统16位代码的寻址能力，达到处理器的最大寻址，此举克服了BIOS代码运行缓慢的弊端。
2.PXE最直接的表现是，在网络环境下工作站可以省去硬盘，但又不是通常所说的无盘站的概念，因为使用该 技术的PC在网络方式下的运行速度要比有盘PC快3倍以上。当然使用PXE的PC也不是传统意义上的TERMINAL终端，因为使用了PXE的PC并不消耗服务器的CPU，RAM等资源，故服务器的硬件要求极低。PXE启动原理为当计算机引导时，BIOS把 PXE Client 调入内存中执行，然后由 PXE Client 将放置在远端的文件通过网络下载到本地运行。

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 1. 了解GRUB的启动流程。
 1. 比较NTLDR和GRUB的功能有差异。
 1. 了解u-boot的功能。

 1.NTLDR（NT loader的缩写）是微软的Windows NT系列操作系统（包括Windows XP和Windows Server 2003）的引导程序。NTLDR可以从硬盘以及CD-ROM、U盘等移动存储器运行并引导Windows NT系统的启动。启动流程如下：电源自检程序开始运行,主引导记录被装入内存，并且程序开始执行,活动分区的引导扇区被装入内存,NTLDR从引导扇区被装入并初始化,将处理器的实模式改为32位平滑内存模式,NTLDR开始运行适当的小文件系统驱动程序。小文件系统驱动程序是建立在NTLDR内部的，它能读FAT或NTFS。,NTLDR读boot.ini文件,NTLDR装载所选操作系统.

 2.grub启动流程：BIOS从MBR中装载GRUB，GRUB装载stage1，装载stage1.5，装载stage2，读取/boot/grub.conf文件并显示启动菜单，装载所选的kernel和initrd文件到内存中。进入内核阶段，挂载文件系统。加载相应的系统。

 3.区别：ntldr功能很少，只能引导win，只能装在硬盘；grub是第三方操作系统引导器，可以引导多种存储介质和多种系统

 4.U-boot功能Universal Boot Loader。普遍的引导程序，是非常常用的一个引导程序，可作为主流系统的引导程序，如OpenBSD, NetBSD, FreeBSD,4.4BSD, Linux, SVR4, Esix, Solaris等等，当然同时也支持多种常见的cpu处理器，如MIPS、 x86、ARM、NIOS、XScale等。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 Linux的系统调用在2.4.4版内核中共有221个，有打开文件、关闭文件、新建进程、销毁进程、分配内存、释放内存等等。
按照其功能大致可以分为以下几类：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket控制、用户管理、进程间通信。


 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 
 ``` 
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```

 ucore中系统调用有二十几个，有打开文件、关闭文件、读取文件、分配内存、释放内存、新建进程、销毁进程等等。
按照其功能大致可以分为以下几类：进程控制、文件系统控制、系统控制、内存管理、进程间通信。

 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```

系统调用是由操作系统实现提供的所有系统调用所构成的集合即程序接口或应用编程接口(Application Programming Interface，API)。是应用程序同系统之间的接口。利用了objdump，nm，file三个命令对源文件进行分析：
1.利用file命令可以确定lab1_ex0.exe的文件类型为elf64-x86-64，即x86架构下的64位的可执行文件。
2.利用nm命令可以列出lab1_ex0.exe的符号清单。从符号清单中可以看到改程序使用了一下系统调用：
0000000000000006 a SYS_close;
000000000000003f a SYS_dup2;
000000000000000b a SYS_execve; 
0000000000000001 a SYS_exit;
0000000000000002 a SYS_fork;
0000000000000013 a SYS_lseek; 
000000000000005a a SYS_mmap;
000000000000005b a SYS_munmap; 
0000000000000005 a SYS_open;
0000000000000066 a SYS_socketcall;
0000000000000005 a SYS_socketcall_accept;
0000000000000002 a SYS_socketcall_bind;
0000000000000004 a SYS_socketcall_listen;
0000000000000001 a SYS_socketcall_socket;
0000000000000004 a SYS_write;

3.利用objdump -d命令将生成的lab1_ex0.exe进行反汇编，得到lab1_ex0.o。首先观察lab1-ex0.s文件，代码的目的是将hello world输出到屏幕，发现其中使用了int 80指令，该指令为linux下的系统调用入口点,该指令通过eax寄存器中的参数来确定采用系统调用的种类，而ecx中的地址作（hello world字符串的首地址）为参数传入，在本程序中程序通过该指令实现了将hello world字符串输出到屏幕。

 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```

strace -c是统计程序执行过程中每一系统调用的所执行的时间、次数和出错的次数。
系统调用执行过程：应用程序调用系统提供的API，然后进入API的执行体，其中给出相对应的系统调用号和参数，由操作系统进行系统调用，指挥硬件进行工作（如访问磁盘上的文件系统），然后操作系统获得系统调用的返回值，再向上返回给API，最后返回给应用程序。
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。

 函数调用主要是用户在编程是实现的，而系统调用主要通过库函数来实现，在用户编程时不会显式地被使用

1. 说明`int`、`iret`、`call`和`ret`的指令准确功能

int:中断信息可以来自CPU的内部和外部，当CPU的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。
iret:IRET(interrupt return)中断返回，中断服务程序的最后一条指令。IRET指令将推入堆栈的段地址和偏移地址弹出，使程序返回到原来发生中断的地方。其作用是从中断中恢复中断前的状态.
call,ret:CALL（LCALL）指令执行时，进行两步操作:1）将程序当前执行的位置IP压入堆栈中,2）转移到调用的子程序。
CALL与RET结合使用，当CALL调用的子程序运行到RET命令时，压入堆栈的IP弹出，跳出子程序，开始执行CALL的下一条语句
