# lab3 SPOC思考题

NOTICE
- 有"w5l2"标记的题是助教要提交到学堂在线上的。
- 有"w5l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 个人思考题
---

### 10.1 实验目标：虚存管理
---

(1)缺页异常的处理流程？

(2)从外存的页面的存储和访问代码？

(3)缺页和页访问非法的返回地址有什么不同？

> 硬件设置、软件可修改； 中断号是

(4)虚拟内存管理中是否用到了段机制

(5)ucore如何知道页访问异常的地址？

### 10.2 回顾历史和了解当下
---

(6)中断处理例程的段表在GDT还是LDT？

(7)物理内存管理的数据结构在哪？

(8)页表项的结构？

(9)页表项的修改代码？

(10)如何设置一个虚拟地址到物理地址的映射关系？

(11)为了建立虚拟内存管理，需要在哪个数据结构中表示“合法”虚拟内存

### 10.3 处理流程、关键数据结构和功能
---

(12)swap_init()做了些什么？

(13)vmm_init()做了些什么？

(14)vma_struct数据结构的功能？

(15)mmap_list是什么列表？

(16)外存中的页面后备如何找到？

(17)vma_struct和mm_struct的关系是什么？

> 合法的连续虚拟地址区域、整个进程的地址空间

(18)画数据结构图，描述进程的虚拟地址空间、页表项、物理页面和后备页面的关系；

### 10.4 页访问异常
---

(19)页面不在内存和页面访问非法的处理中有什么区别？对应的代码区别在哪？

(20)find_vma()做了些什么？

(21)swapfs_read()做了些什么？

(22)缺页时的页面创建代码在哪？

(23)struct rb_tree数据结构的原理是什么？在虚拟管理中如何用它的？


(24)页目录项和页表项的dirty bit是何时，由谁置1的？


(25)页目录项和页表项的access bit是何时，由谁置1的？


### 10.5 页换入换出机制
---

(26)虚拟页与磁盘后备页面的对应有关系？

(27)如果在开始加载可执行文件时，如何改？

(28)check_swap()做了些什么检查？

(29)swap_entry_t数据结构做什么用的？放在什么地方？

(30)空闲物理页面的组织数据结构是什么？

(21)置换算法的接口数据结构？

> swap_manager

================


## 小组思考题
---
(1)(spoc) 请参考lab3_result的代码，思考如何在lab3_results中实现clock算法，并给出你的概要设计方案，可4人一个小组，说明你的方案中clock算法与LRU算法上相比，潜在的性能差异性。并进一说明LRU算法在lab3实现的可能性评价（给出理由）。
```
设计方案：
1.在分配内存时，将已经map到物理内存中的页面利用pra_page_link结构构成一个链环，把mm中的sm_priv指向其中一个页面。
2.在需要进行页面置换时，依次查找各个物理页面对应的页表项，检查其访问位，若为0则换出，否则将其置0后继续遍历。
3.访问位可以在页表项里的PET_A(accessed)来充当。
4.其余实现和FIFO近似，不再赘述。

潜在的性能差异：
LRU不仅要记录是否访问，还要记录访问的时间，需要占用更大的内存空间，也需要CPU进行更复杂的硬件层面支持，访问时的消耗要大很多。
LRU进行页面置换时需要遍历所有物理页面的页表项，找出其中访问时间最早的一项，而CLOCK不一定完全遍历。
总体缺页率而言，LRU更好一些。

LRU在Lab3实现的可能性：
不可能实现，因为这需要CPU支持在访问内存时记录访问时间，而Lab中的CPU仅能在访问时对标记位进行标记。
```

(2)(spoc) 理解内存访问的异常。在x86中内存访问会受到段机制和页机制的两层保护，请基于lab3_results的代码（包括lab1的challenge练习实现），请实践并分析出段机制和页机制各种内存非法访问的后果。，可4人一个小组，，找出尽可能多的各种内存访问异常，并在代码中给出实现和测试用例，在执行了测试用例后，ucore能够显示出是出现了哪种异常和尽量详细的错误信息。请在说明文档中指出：某种内存访问异常的原因，硬件的处理过程，以及OS如何处理，是否可以利用做其他有用的事情（比如提供比物理空间更大的虚拟空间）？哪些段异常是否可取消，并用页异常取代？
```
1. 访问一个非法的地址：0x100
page fault at 0x00000100: K/W [no page found].
kernel panic at kern/trap/trap.c:165:
unhandled page fault.  

2. 没有设置GDT 注释掉lgdt语句
qemu: fatal: Trying to execute code outside RAM or ROM at 0xc0100012

3. 没有设置IDT 注释掉idt_init()
在触发时钟中断的时候重启,因为找不断处理中断的代码

4. 页目录项不存在 将页目录项中present位置为0
kernel panic at kern/mm/pmm.c:550:  
assertion failed: (ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL  

5. 试图用一个超过段界限的偏移量访问段
将将gdt表中SEG_ASM的最后一项值（limit)置为0
修改bootloader里的gdt无法启动
修改entry里gdt的，不断重启

6. 使用空选择子 用ljmp语句强行将cs寄存器的值设置为0
使用语句为：asm volatile ("ljmp $0x0, $0x1111"); 结果出现General Protection

trapframe at 0xc011ef34
  edi  0x00000001
  esi  0x00000000
  ebp  0xc011ef88
  oesp 0xc011ef54
  ebx  0x00010094
  edx  0xc010a39f
  ecx  0x00000000
  eax  0x0000001e
  ds   0x----0010
  es   0x----0010
  fs   0x----0023
  gs   0x----0023
  trap 0x0000000d General Protection
  err  0x00000000
  eip  0xc0107919
  cs   0x----0008
  flag 0x00000086 PF,SF,IOPL=0
kernel panic at kern/trap/trap.c:221:
    unexpected trap in kernel.

1.段访问越界
硬件处理过程：检查访问地址是否越界->越界，产生异常->装入异常相关信息->查中断向量表->跳转到中断程序执行。
OS处理过程：收集错误信息->报告错误->关闭相应进程

2.访问不存在的页面
硬件处理过程：查TLB相应页表项->不存在，产生异常->装入异常相关信息->查中断向量表->跳转到中断程序执行。
OS处理过程：检查页面是否存在->不存在，报错退出

3.用户态访问内核态的地址
硬件处理过程：检查地址访问权限是否允许->不允许，产生异常->装入异常相关信息->查中断向量表->跳转到中断程序执行。
OS处理过程：收集错误信息->报告错误->关闭相应进程

4.缺页异常
硬件处理过程：查TLB相应页表项->不存在，产生异常->装入异常相关信息->查中断向量表->跳转到中断程序执行。
OS处理过程：检查页面是否存在->存在，检查页面是否已映射到物理内存->若已映射，则更新TLB并返回；若尚未映射，则依据一些算法将页面换入映射，然后更新TLB并返回。
```
