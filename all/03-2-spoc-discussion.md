# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
1.  为什么要设计非连续内存分配机制？

    > 1. 连续分配存在很多缺点：
    >
    >    非配给程序的物理内存必须连续，很难实现
    >
    >    存在外碎片和内碎片
    >
    >    内存分配的动态修改困难
    >
    >    内存利用率较低
    >
    > 2. 非连续分配的特点可较好解决这些问题
    >
    >     允许一个程序使用非连续的物理地址空间，使内存分配变得容易
    >
    >     允许共享代码数据,可减少内存使用量
    >
    >     支持动态加载和动态链接，更加灵活
    >
    >

2.  非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变

    > 有段式存储（大块）和页式存储（小块）两种

3.  为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

    > 段的长度是由程序和数据决定的，便于针对不同的程序段分别进行编译或设置不同的保护等
    >
    > 页设计成固定大小以方便管理。
    >
    > 小块的固定大小有多种选择，要求是2的n次方。

      ### 6.2段式存储管理

4.  什么是段、段基址和段内偏移？

    > 段：段表示访问方式和存储数据等属性相同的一段地址空间；对应一个连续的内存“块”；若干个段组成进程逻辑地址空间
    >
    > 段基地址:规定线性地址空间中段的起始地址。
    >
    > 段内偏移：程序的逻辑地址与段首的差值。

5.  段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

    > 转换流程：首先用逻辑地址的段号去查段表，找到对应的段描述符，将段描述符中的长度与逻辑地址的偏移比较，看是否越界，如果没有越界，MMU将段基质和偏移加起来就能够找到实际要访问的内容。
    >
    > 因为依据段表可以定位每一个段，所以不需要连续。
    >
    > 好处是可以充分实现共享和保护，便于动态申请内存，管理和使用统一化，便于动态链接。麻烦是有碎片问题；如果段表存储在内存中，那每次读取数据都需要两次访存，会降低速度，需要一些特定的方法解决这个问题。

      ### 6.3页式存储管理

6.  什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

    > 帧：把物理地址空间划分为大小相同的基本分配单位
    >
    > 页：把逻辑地址空间也划分为相同大小的基本分配单位
    >
    > 页表：保存逻辑地址到物理地址之间的映射关系的表
    >
    > 存储管理单元：中央处理器CPU中用来管理虚拟存储器、物理存储器的控制线路，负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。
    >
    > 快表：可理解为页表的缓冲，里面存放的是一些页表文件
    >
    > 高速缓存：一种存在于主存与CPU之间的特殊的存储器子系统，其中复制了频繁使用的数据，以利于CPU快速访问。

7.  页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

    > 根据逻辑地址中的逻辑页号到页表中寻找对应的物理页号。页表由页表基址指定开始位置，以页号为下标就能找到对应的页表项。帧号是页表项中存的一个字段，帧内偏移与页内偏移一样，有了帧号与帧内偏移即可得对应的物理地址。
    >
    > 可以不连续是因为有页表可以定位每一个页。
    >
    > 优点：可以有效的解决碎片问题；动态页式管理提供了内存和外存统一管理的虚存实现方式，使用户可以利用的存储空间大大增加。这既提高了主存的利用率，又有利于组织多道程序执行。
    >
    > 缺点：和段机制一样可能需要多次存储访问，影响效率；页表可能很大，占内存；虽然消除了外部碎片，但有内部碎片；增加了系统开销，如缺页中断处理。

    ### 6.4页表概述
8.  每个页表项有些什么内容？有哪些标志位？它们起什么作用？

    > 页表项中有 帧号和页表项标志
    >
    > 标志位：
    >
    > ​	存在位——是否有一个物理帧与这个逻辑页号相对应。
    >
    > ​        修改位——对应的页面里面的内容是否修改了
    >
    > ​        引用位——在过去一段时间内是否有对对应的页面的引用

9.  页表大小受哪些因素影响？

    > 页大小、地址空间大小、进程数目

    ### 6.5快表和多级页表
10.  快表（TLB）与高速缓存（cache）有什么不同？

    > TLB中存放的是页表，cache中存放的是最近使用的数据和指令；cache是主存与cpu之间，	TLB是主存与辅存之间的

11.  为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

    > 因为快表是存在cpu中，不需要访存。
    >
    > 实现：快表就是把近期访问过的页表项缓存到cpu中，用关联存储器实现，可以并行的查找所有表项。
    >
    > 容量小是因为它成本高，功耗大。

12.  什么是多级页表？多级页表中的地址转换流程是什么？多组页面有什么好处和麻烦？

    > 多级页表是通过间接引用，将页号分成若干级，形成树状结构的页表。它每一个子页表的起头作为上一级页表的物理页号填到上一级页表当中。
    >
    > 转换流程：第一级页表项作为第一级页表的偏移，找到第二级页表上的起始；第二级页表项再作为在第二级页表当中的偏移加在一起找到第三级页表项的，类推直至最后一级页表，加上偏移量就是最终的物理地址。
    >
    > 好处：减少页表长度；通过各级页表中的存在位，省略的不存在的页表，减少内存消耗。
    >
    > 缺点是需要多次访问内存，开销大。

      ### 6.6反置页表

13.  页寄存器机制的地址转换流程是什么？

    > 把逻辑地址做Hash,减少搜索范围，然后在快表当中去查找相应的页表项,如果说查找的过程当中出现冲突 ,就需要遍历所有的冲突链表,如果查找不到,就会出现异常.

14.  反置页表机制的地址转换流程是什么？

    > 与页寄存器做法一样的它需要进行Hash不同的地方是把进程标识也加在里头一块做Hash。Hash完的结果以页帧号来排序，找到结果后到相应的页表项去核对，hash前后的进程id与逻辑号是否一致，如果一致就是找到了，如果不一致就去下一项核对。

15.  反置页表项有些什么内容？

    > PID、逻辑页号、标志位

    ### 6.7段页式存储管理
16.  段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

    > 段号由进程的段基址,找到相应的段表项,  段表项里有相应段的段长度和段基址，由此可得相应段的页表的基址，加上逻辑地址中的页号可得我就可以得到相应的页表项，页表项里有对应的物理页的页帧号，这个页帧号和页内偏移加在一起，就可以访问到实际的物理存储单元了。
    >
    > 好处：同时拥有段式管理和页式管理的优点，如，没有外部碎片，针对不同的段可分别编写和编译，针对不同类型的段采用不同的保护，按段为单位进行共享等。

17.  如何实现基于段式存储管理的内存共享？

    >  两个段表项指向同一个段。

18.  如何实现基于页式存储管理的内存共享？

    >  两个页表项指向同一个物理页。

## 个人思考题
---

#### （1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的

```
  + 采分点：说明64bit CPU架构的分页机制的大致特点和页表执行过程
  - 答案没有涉及如下3点；（0分）
  - 正确描述了64bit CPU支持的物理内存大小限制（1分）
  - 正确描述了64bit CPU下的多级页表的级数和多级页表的结构或反置页表的结构（2分）
  - 除上述两点外，进一步描述了在多级页表或反置页表下的虚拟地址-->物理地址的映射过程（3分）
```
>  以linux为例，使用基于多级分页机制的内存管理，x86-64 CPU的实际虚拟地址大小为48位（64位中的低48位，高16位不用于地址转换），可寻址256TB地址空间（不同的CPU不相同，但最大不超过52位）。
>
>  使用四级分页，一个页的大小为4k。每一级页表的大小都为4k，由512个8字节的页表项组成。
>
>  虚拟地址结构：大小为8个字节（64位，实际只使用低48位），包含着找到物理地址的信息分为5个部分：第39位到第47位这9位（最高9位） 是一级页表中的索引，第30位到第38位这9位是二级页表中的索引，第21位到第29位这9位是三级页表中的索引，第12位到第20位这9位是四级页表中的索引，第0位到第11位 这12位（低12位）是页内偏移。
>
>  虚拟地址到物理地址的转换过程：对于一个要转换成物理地址的虚拟地址，CPU首先根据CR3（保存一级页表物理地址的寄存器）中的值，找到一级页表所在的物理页，然后根据虚拟地址的第39位到第47位这9位（最高9位）的值作为索引，找到相应的一级页表项，一级页表项中有这个虚拟地址所对应的二级页表的物理地址。有了二级页表的物理地址，根据虚拟地址的第30位到第38位这9位的值作为索引，找到该二级页表中相应的二级页表项，二级页表项中有这个虚拟地址所对应的三级页目录的物理地址。有了三级页目录的物理地址，根据虚拟地址的第21位到第29位这9位的值作为索引，找到该页目录中相应的三级页目录项，页目录项中有这个虚拟地址所对应的四级页表的物理地址。有了四级页表的物理地址，根据虚拟地址的第12位到第20位这9位的值作为索引，找到该页表中相应的四级页表项，四级页表项中有这个虚拟地址所对应的物理页的物理地址。最后用虚拟地址的最低12位，也就是页内偏移，加上这个物理页的物理地址，就得到了该虚拟地址所对应的物理地址。

## 小组思考题
---

（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。 

- [x] ​

> 500=0.9\*150+0.1\*x

（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)
      
Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```



（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。


（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。


 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture06#head-1f58ea81c046bd27b196ea2c366d0a2063b304ab)
--- 

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。

---


## interactive　understand VM

- [Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)

