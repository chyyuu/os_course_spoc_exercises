# lec5 SPOC思考题


NOTICE
- 有"w3l1"标记的题是助教要提交到学堂在线上的。
- 有"w3l1"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。


## 个人思考题
---

请简要分析最优匹配，最差匹配，最先匹配，buddy systemm分配算法的优势和劣势，并尝试提出一种更有效的连续内存分配算法 (w3l1)

* 最优匹配
    - 优势：
        + 大部分分配的尺寸较小时，效果很好 
        + 可避免大的空闲分区被拆分
        + 可减小外部碎片大小
        + 相对简单
    - 劣势：
        + 外部碎片
        + 释放分区较慢
        + 容易产生很多无用的小碎片
* 最差匹配
    - 优势：
        + 中等大小的分配较多时，效果最好
        + 避免出现太多的小碎片
    - 劣势：
        + 释放分区较慢
        + 外部碎片
        + 容易破坏大的空闲分区，因此后续难以分配大的分区
* 最先匹配
    - 优势：
        1. 简单
        2. 在高地址有大块的空闲分区
    - 劣势：
        1. 外部碎片
        2. 分配大块时较慢
* buddy system
    - 优势：
        + 实现简单
        + 动态分配释放
    - 劣势：
        + 一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。
        + 存在一定的浪费现象
        + 拆分和合并涉及到较多的链表和位图操作，开销较大
        + 可能有这样的情况发生：空闲内存的总大小大于某内存分配请求要求的内存大小，但无法分配出内存（简单举例，系统管理的总内存大小是1024K，粒度为16K，第一次分配请求10K内存，分配成功后还剩余的空闲内存实际为1024K - 16K = 1008K，但此时再请求600K(>512K)内存时失败）。

```
  + 采分点：说明四种算法的优点和缺点
  - 答案没有涉及如下3点；（0分）
  - 正确描述了二种分配算法的优势和劣势（1分）
  - 正确描述了四种分配算法的优势和劣势（2分）
  - 除上述两点外，进一步描述了一种更有效的分配算法（3分）
 ```
- [x]  

>  

## 小组思考题

请参考ucore lab2代码，采用`struct pmm_manager` 根据你的`学号 mod 4`的结果值，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在应用程序层面(可以 用python,ruby,C++，C，LISP等高语言)来实现，给出你的设思路，并给出测试用例。 (spoc)
2012011335 % 4 = 3:buddy system


--- 

## 扩展思考题

阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。


